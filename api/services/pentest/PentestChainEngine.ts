import { LLMService, LLMConfig, LLMRequest } from '../services/ai/LLMService';
import { ToolManager } from '../services/tools/ToolManager';
import { v4 as uuidv4 } from 'uuid';

export interface PentestContext {
  target: string;
  targetInfo: {
    ip?: string;
    domain?: string;
    ports?: number[];
    services?: Array<{
      port: number;
      service: string;
      version?: string;
    }>;
  };
  vulnerabilities: any[];
  scanResults: any[];
  previousActions: Array<{
    action: string;
    result: any;
    timestamp: Date;
  }>;
}

export interface PentestChainNode {
  id: string;
  type: 'reconnaissance' | 'scanning' | 'exploitation' | 'post_exploitation';
  name: string;
  description: string;
  prerequisites: string[];
  tools: string[];
  aiPrompt: string;
  successCriteria: string[];
  nextNodes: string[];
  timeout: number;
  retryCount: number;
}

export interface ExecutionResult {
  success: boolean;
  data?: any;
  error?: string;
  nextAction?: string;
  confidence: number;
  executionTime: number;
}

export class PentestChainEngine {
  private llmService: LLMService;
  private toolManager?: ToolManager;
  private currentChain: PentestChainNode[] = [];
  private executionContext: Map<string, any> = new Map();

  constructor(llmService: LLMService, toolManager?: ToolManager) {
    this.llmService = llmService;
    this.toolManager = toolManager;
  }

  async executeChain(taskId: string, target: string, config: LLMConfig): Promise<{
    success: boolean;
    results: any[];
    vulnerabilities: any[];
    executionTime: number;
  }> {
    const startTime = Date.now();
    const results: any[] = [];
    const vulnerabilities: any[] = [];

    try {
      // 初始化渗透上下文
      const context = await this.initializeContext(target);
      
      // 构建渗透链
      this.currentChain = await this.buildChain(context, config);
      
      // 执行渗透链
      for (const node of this.currentChain) {
        const result = await this.executeNode(node, context, config);
        results.push({
          nodeId: node.id,
          nodeType: node.type,
          result: result,
          timestamp: new Date()
        });

        if (result.success && result.data) {
          // 提取漏洞信息
          const vulns = this.extractVulnerabilities(result.data, node.type);
          vulnerabilities.push(...vulns);
        }

        // 更新上下文
        context.previousActions.push({
          action: node.name,
          result: result,
          timestamp: new Date()
        });

        // 检查是否需要调整链
        if (this.shouldAdaptChain(result, node)) {
          this.currentChain = await this.adaptChain(this.currentChain, result, context, config);
        }
      }

      const executionTime = Date.now() - startTime;
      return {
        success: true,
        results,
        vulnerabilities: this.deduplicateVulnerabilities(vulnerabilities),
        executionTime
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;
      return {
        success: false,
        results,
        vulnerabilities,
        executionTime
      };
    }
  }

  private async initializeContext(target: string): Promise<PentestContext> {
    // 解析目标信息
    const targetInfo = await this.parseTarget(target);
    
    return {
      target,
      targetInfo,
      vulnerabilities: [],
      scanResults: [],
      previousActions: []
    };
  }

  private async parseTarget(target: string): Promise<PentestContext['targetInfo']> {
    // 简单的目标解析逻辑
    const targetInfo: PentestContext['targetInfo'] = {};
    
    // 判断是IP还是域名
    if (/^\d+\.\d+\.\d+\.\d+$/.test(target)) {
      targetInfo.ip = target;
    } else {
      targetInfo.domain = target;
    }

    return targetInfo;
  }

  private async buildChain(context: PentestContext, config: LLMConfig): Promise<PentestChainNode[]> {
    const prompt = `
      作为渗透测试专家，请为以下目标制定详细的渗透测试计划：
      
      目标：${context.target}
      目标信息：${JSON.stringify(context.targetInfo, null, 2)}
      
      请生成一个结构化的渗透测试链，包含以下阶段：
      1. reconnaissance（信息收集）
      2. scanning（漏洞扫描）  
      3. exploitation（漏洞利用）
      4. post_exploitation（后渗透）
      
      每个阶段应该包含：
      - 具体的测试步骤
      - 推荐的工具
      - 成功标准
      - 执行顺序
      
      请以JSON数组格式返回，每个元素包含：id、type、name、description、prerequisites、tools、aiPrompt、successCriteria、nextNodes、timeout、retryCount字段。
    `;

    const request = {
      messages: [
        { role: 'system', content: '你是一个专业的网络安全专家，具有丰富的渗透测试经验。' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.3
    };

    try {
      const response = await this.llmService.generateResponse(request, config);
      const chainData = JSON.parse(response.content);
      return chainData.map((node: any) => ({
        ...node,
        id: node.id || uuidv4(),
        timeout: node.timeout || 300000, // 5分钟默认超时
        retryCount: node.retryCount || 3
      }));
    } catch (error) {
      // 如果AI生成失败，使用默认链
      return this.getDefaultChain();
    }
  }

  private getDefaultChain(): PentestChainNode[] {
    return [
      {
        id: 'recon-1',
        type: 'reconnaissance',
        name: '基础信息收集',
        description: '收集目标的基础信息，包括域名、IP、端口等',
        prerequisites: [],
        tools: ['nmap', 'nslookup', 'dig'],
        aiPrompt: '分析目标的基础信息',
        successCriteria: ['获取目标IP地址', '识别开放端口', '发现服务信息'],
        nextNodes: ['scan-1'],
        timeout: 300000,
        retryCount: 3
      },
      {
        id: 'scan-1',
        type: 'scanning',
        name: '漏洞扫描',
        description: '使用自动化工具扫描已知漏洞',
        prerequisites: ['recon-1'],
        tools: ['nmap', 'sqlmap', 'nikto'],
        aiPrompt: '基于信息收集结果进行漏洞扫描',
        successCriteria: ['完成漏洞扫描', '识别潜在漏洞', '生成扫描报告'],
        nextNodes: ['exploit-1'],
        timeout: 600000,
        retryCount: 2
      },
      {
        id: 'exploit-1',
        type: 'exploitation',
        name: '漏洞验证',
        description: '验证发现的漏洞，生成POC代码',
        prerequisites: ['scan-1'],
        tools: ['metasploit', 'custom_poc'],
        aiPrompt: '基于扫描结果生成漏洞验证代码',
        successCriteria: ['验证漏洞存在', '生成POC代码', '确认可利用性'],
        nextNodes: ['post-1'],
        timeout: 450000,
        retryCount: 2
      },
      {
        id: 'post-1',
        type: 'post_exploitation',
        name: '后渗透分析',
        description: '获取系统信息，提升权限，横向移动',
        prerequisites: ['exploit-1'],
        tools: ['meterpreter', 'powersploit'],
        aiPrompt: '进行后渗透测试和权限提升',
        successCriteria: ['获取系统访问权限', '收集敏感信息', '完成渗透测试'],
        nextNodes: [],
        timeout: 300000,
        retryCount: 1
      }
    ];
  }

  private async executeNode(node: PentestChainNode, context: PentestContext, config: LLMConfig): Promise<ExecutionResult> {
    const startTime = Date.now();
    
    try {
      // 检查前置条件
      if (!this.checkPrerequisites(node, context)) {
        return {
          success: false,
          error: '前置条件未满足',
          confidence: 0,
          executionTime: Date.now() - startTime
        };
      }

      // 根据节点类型执行相应的逻辑
      let result: ExecutionResult;
      
      switch (node.type) {
        case 'reconnaissance':
          result = await this.executeReconnaissance(node, context, config);
          break;
        case 'scanning':
          result = await this.executeScanning(node, context, config);
          break;
        case 'exploitation':
          result = await this.executeExploitation(node, context, config);
          break;
        case 'post_exploitation':
          result = await this.executePostExploitation(node, context, config);
          break;
        default:
          throw new Error(`Unknown node type: ${node.type}`);
      }

      result.executionTime = Date.now() - startTime;
      return result;
    } catch (error) {
      return {
        success: false,
        error: error.message,
        confidence: 0,
        executionTime: Date.now() - startTime
      };
    }
  }

  private checkPrerequisites(node: PentestChainNode, context: PentestContext): boolean {
    // 检查所有前置条件是否满足
    for (const prerequisite of node.prerequisites) {
      const completedAction = context.previousActions.find(
        action => action.action === prerequisite && action.result.success
      );
      if (!completedAction) {
        return false;
      }
    }
    return true;
  }

  private async executeReconnaissance(node: PentestChainNode, context: PentestContext, config: LLMConfig): Promise<ExecutionResult> {
    try {
      const active = process.env.ALLOW_ACTIVE_ATTACKS === 'true';
      if (active && this.toolManager) {
        const r = await this.toolManager.executeTool({ toolName: 'nmap', args: ['-sV', '-T4', '-Pn'], target: context.target, timeout: 300000 });
        const data = { ports: r.parsedData?.ports || [], services: r.parsedData?.services || [], raw: r.output };
        return { success: r.success, data, confidence: r.success ? 0.9 : 0.3, executionTime: 0 };
      }
      const prompt = `模拟对目标 ${context.target} 的信息收集过程，生成真实的信息收集结果。包含：端口扫描结果、服务识别、DNS信息、WHOIS信息等。请以JSON格式返回详细的扫描结果。`;
      const request = { messages: [ { role: 'system', content: '你是一个网络扫描工具，生成真实的扫描结果。' }, { role: 'user', content: prompt } ], temperature: 0.3 } as any;
      const response = await this.llmService.generateResponse(request, config);
      const scanData = JSON.parse(response.content);
      return { success: true, data: scanData, confidence: 0.8, executionTime: 0 };
    } catch (error) {
      return { success: false, error: (error as any).message, confidence: 0, executionTime: 0 };
    }
  }

  private async executeScanning(node: PentestChainNode, context: PentestContext, config: LLMConfig): Promise<ExecutionResult> {
    try {
      const active = process.env.ALLOW_ACTIVE_ATTACKS === 'true';
      if (active && this.toolManager) {
        const r = await this.toolManager.executeTool({ toolName: 'nikto', args: ['-h'], target: context.target, timeout: 300000 });
        const data = { vulnerabilities: r.parsedData?.vulnerabilities || [], server: r.parsedData?.server || null, raw: r.output };
        return { success: r.success, data, confidence: r.success ? 0.8 : 0.3, executionTime: 0 };
      }
      const prompt = `基于以下信息收集结果，进行漏洞扫描分析：${JSON.stringify(context.previousActions[context.previousActions.length - 1]?.result?.data)} 请识别潜在的安全漏洞，包含开放端口的安全风险、服务版本的已知漏洞、配置安全问题等。以JSON格式返回详细的漏洞扫描结果。`;
      const request = { messages: [ { role: 'system', content: '你是一个漏洞扫描工具，生成真实的漏洞扫描结果。' }, { role: 'user', content: prompt } ], temperature: 0.3 } as any;
      const response = await this.llmService.generateResponse(request, config);
      const vulnData = JSON.parse(response.content);
      return { success: true, data: vulnData, confidence: 0.75, executionTime: 0 };
    } catch (error) {
      return { success: false, error: (error as any).message, confidence: 0, executionTime: 0 };
    }
  }

  private async executeExploitation(node: PentestChainNode, context: PentestContext, config: LLMConfig): Promise<ExecutionResult> {
    try {
      // 基于扫描结果生成POC代码
      const scanResult = context.previousActions[context.previousActions.length - 1]?.result?.data;
      
      if (!scanResult || !scanResult.vulnerabilities || scanResult.vulnerabilities.length === 0) {
        return {
          success: true,
          data: { message: '未发现可利用的漏洞' },
          confidence: 1.0,
          executionTime: 0
        };
      }

      // 为每个漏洞生成POC
      const pocResults = [];
      for (const vulnerability of scanResult.vulnerabilities) {
        const pocResult = await this.llmService.generatePocCode(vulnerability);
        pocResults.push({
          vulnerability: vulnerability,
          poc: pocResult
        });
      }

      return {
        success: true,
        data: {
          pocResults,
          message: `成功生成 ${pocResults.length} 个漏洞的POC代码`
        },
        confidence: 0.7,
        executionTime: 0
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        confidence: 0,
        executionTime: 0
      };
    }
  }

  private async executePostExploitation(node: PentestChainNode, context: PentestContext, config: LLMConfig): Promise<ExecutionResult> {
    try {
      // 后渗透分析
      const exploitationResult = context.previousActions[context.previousActions.length - 1]?.result?.data;
      
      const prompt = `
        基于以下漏洞利用结果，进行后渗透分析：
        ${JSON.stringify(exploitationResult, null, 2)}
        
        请分析：
        1. 获取的系统权限
        2. 可能的横向移动路径
        3. 敏感信息收集
        4. 持久化建议
        
        以JSON格式返回后渗透分析结果。
      `;

      const request = {
        messages: [
          { role: 'system', content: '你是一个后渗透测试专家，分析系统被入侵后的情况。' },
          { role: 'user', content: prompt }
        ],
        temperature: 0.3
      };

      const response = await this.llmService.generateResponse(request, config);
      const postExploitData = JSON.parse(response.content);

      return {
        success: true,
        data: postExploitData,
        confidence: 0.6,
        executionTime: 0
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        confidence: 0,
        executionTime: 0
      };
    }
  }

  private shouldAdaptChain(result: ExecutionResult, currentNode: PentestChainNode): boolean {
    // 如果执行失败或者置信度较低，考虑调整链
    return !result.success || result.confidence < 0.5;
  }

  private async adaptChain(chain: PentestChainNode[], result: ExecutionResult, context: PentestContext, config: LLMConfig): Promise<PentestChainNode[]> {
    // 这里可以实现更复杂的链调整逻辑
    // 现在简单返回原链
    return chain;
  }

  private extractVulnerabilities(data: any, nodeType: string): any[] {
    const vulnerabilities = [];
    
    if (data.vulnerabilities) {
      vulnerabilities.push(...data.vulnerabilities);
    }
    
    if (data.pocResults) {
      for (const pocResult of data.pocResults) {
        vulnerabilities.push({
          ...pocResult.vulnerability,
          pocGenerated: true,
          pocCode: pocResult.poc.code
        });
      }
    }

    return vulnerabilities.map(v => ({
      ...v,
      discoveredBy: nodeType,
      discoveredAt: new Date()
    }));
  }

  private deduplicateVulnerabilities(vulnerabilities: any[]): any[] {
    const seen = new Set();
    return vulnerabilities.filter(vuln => {
      const key = `${vuln.type}-${vuln.component}-${vuln.severity}`;
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }
}
